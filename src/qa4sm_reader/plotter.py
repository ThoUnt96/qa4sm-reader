# -*- coding: utf-8 -*-

from qa4sm_reader.img import QA4SMImg
import qa4sm_reader.globals as globals
import os
import seaborn as sns
from qa4sm_reader.plot_utils import *
import pandas as pd

def _make_cbar(fig, im, cax, ref_short:str, metric:str, label=None):
    """
    Make colorbar to use in plots

    Parameters
    ----------
    fig: matplotlib.figure.Figure
        figure of plot
    im: AxesImage
        from method Axes.imshow()
    cax: axes.SubplotBase
        from fig.add_subplot
    ref_short: str
        name of ref dataset
    metric: str
        name of metric
    label: str
        label to describe the colorbar
    """
    if label is None:
        try:
            label = globals._metric_name[metric] + \
                    globals._metric_description[metric].format(
                        globals._metric_units[ref_short])
        except KeyError as e:
            raise Exception('The metric \'{}\' or reference \'{}\' is not known.\n'.format(metric, ref_short) + str(e))

    extend = get_extend_cbar(metric)
    cbar = fig.colorbar(im, cax=cax, orientation='horizontal', extend=extend)
    cbar.set_label(label, weight='normal')
    cbar.outline.set_linewidth(0.4)
    cbar.outline.set_edgecolor('black')
    cbar.ax.tick_params(width=0.4)

    return fig, im, cax

def boxplot(df, label=None, figsize=None, dpi=100, **kwargs): # todo: after changes, check that boxplot works when two equal datasets are on the left
    """
    Create a boxplot_basic from the variables in df.
    The box shows the quartiles of the dataset while the whiskers extend
    to show the rest of the distribution, except for points that are
    determined to be “outliers” using a method that is a function of
    the inter-quartile range.

    Parameters
    ----------
    df : pandas.DataFrame
        DataFrame containing 'lat', 'lon' and (multiple) 'var' Series.
    title : str, optional (default: None)
        Title of the plot. If None, no title is added.
    label : str, optional
        Label of the y axis, describing the metric. If None, a label is autogenerated from metadata.
        The default is None.
    figsize : tuple, optional
        Figure size in inches. The default is globals.map_figsize.
    dpi : int, optional
        Resolution for raster graphic output. The default is globals.dpi.

    Returns
    -------
    fig : matplotlib.figure.Figure
        the boxplot
    ax : matplotlib.axes.Axes
    """
    df = df.copy()
    # make plot
    sns.set_style("whitegrid")
    fig, ax = plt.subplots(figsize=figsize, dpi=dpi)
    ax = sns.boxplot(data=df,
                     ax=ax,
                     width=0.15,
                     showfliers=False,
                     color='white',
                     **kwargs)
    sns.despine()  # remove ugly spines (=border around plot) right and top.

    if label is not None:
        ax.set_ylabel(label, weight='normal')

    return fig, ax

def mapplot(df, metric, ref_short, ref_grid_stepsize=None,
            plot_extent=None, colormap=None, projection=None,
            add_cbar=True, label=None, figsize=globals.map_figsize,
            dpi=globals.dpi, diff_range=None, **style_kwargs):
        """
        Create an overview map from df using values as color. Plots a scatterplot for ISMN and an image plot for other
        input values.

        Parameters
        ----------
        df : pandas.Series
            values to be plotted. Generally from metric_df[Var]
        metric: str
            name of the metric for the plot
        ref_short: str
                short_name of the reference dataset (read from netCDF file)
        ref_grid_stepsize: float or None, optional (None by default)
                angular grid stepsize, needed only when ref_is_angular == False,
        plot_extent: tuple
                (x_min, x_max, y_min, y_max) in Data coordinates. The default is None.
        colormap:  Colormap, optional
                colormap to be used.
                If None, defaults to globals._colormaps.
        projection:  cartopy.crs, optional
                Projection to be used. If none, defaults to globals.map_projection.
                The default is None.
        add_cbar: bool, optional
                Add a colorbar. The default is True.
        label : str, optional
            Label of the y axis, describing the metric. If None, a label is autogenerated from metadata.
            The default is None.
        figsize: tuple, optional
            Figure size in inches. The default is globals.map_figsize.
        dpi: int, optional
            Resolution for raster graphic output. The default is globals.dpi.
        diff_range: None, 'adjusted' or 'fixed'
            if none, globals._metric_value_ranges is used to define the bar extent; if 'fixed', globals._diff_value_ranges
            is used instead; if 'adjusted', max and minimum values are used
        **style_kwargs :
            Keyword arguments for plotter.style_map().

        Returns
        -------
        fig : matplotlib.figure.Figure
            the boxplot
        ax : matplotlib.axes.Axes
        """
        v_min, v_max = get_value_range(df, metric)  # range of values
        if diff_range and diff_range == 'adjusted':
            v_min, v_max = get_value_range(df, metric=None)
        elif diff_range and diff_range == 'fixed':
            v_min, v_max = get_value_range(df, metric, type='diff')

        # initialize plot
        fig, ax, cax = init_plot(figsize, dpi, add_cbar, projection)
        if not colormap:
            cmap = globals._colormaps[metric]
        else:
            cmap = colormap

        # scatter point or mapplot
        if ref_short in globals.scattered_datasets:  # scatter
            if not plot_extent:
                plot_extent = get_plot_extent(df)

            markersize = globals.markersize ** 2
            lat, lon = globals.index_names
            im = ax.scatter(df.index.get_level_values(lon),
                            df.index.get_level_values(lat),
                            c=df, cmap=cmap, s=markersize,
                            vmin=v_min, vmax=v_max,
                            edgecolors='black', linewidths=0.1,
                            zorder=2, transform=globals.data_crs)
        else:  # mapplot
            if not plot_extent:
                plot_extent = get_plot_extent(df, grid_stepsize=ref_grid_stepsize, grid=True)
            zz, zz_extent, origin = geotraj_to_geo2d(df, grid_stepsize=ref_grid_stepsize)  # prep values
            im = ax.imshow(zz, cmap=cmap, vmin=v_min,
                           vmax=v_max, interpolation='nearest',
                           origin=origin, extent=zz_extent,
                           transform=globals.data_crs, zorder=2)

        if add_cbar:  # colorbar
            _make_cbar(fig, im, cax, ref_short, metric, label=label)
        style_map(ax, plot_extent, **style_kwargs)
        fig.canvas.draw()  # very slow. necessary bcs of a bug in cartopy: https://github.com/SciTools/cartopy/issues/1207

        return fig, ax

def diff_plot(ref_df:pd.DataFrame, other_dfs:list, ref_name:str, other_names:list, **kwargs):
    """
    Create a Bland Altman plot for a Dataframe and a list of other Dataframes. Difference is other - reference.

    Parameters
    ----------
    ref_df : pd.DataFrame
        Dataframe of the reference values
    other_dfs: list
        list of Dataframes for the values to be compared
    ref_name : str
        name of the reference
    other_names : list
        list of names of the comparisons

    Returns
    -------
    fig : matplotlib.figure.Figure
        the boxplot
    ax : matplotlib.axes.Axes
    """
    ref_values = np.asarray(ref_df)
    fig, axes = plt.subplots(figsize=(16,10))
    colors = plt.cm.cividis(np.linspace(0,1, len(other_dfs)))

    for df, name, c in zip(other_dfs, other_names, colors):
        other_values = np.asarray(df)
        mean = np.mean([ref_values, other_values], axis=0)
        diff = other_values - ref_values
        md = np.mean(diff)
        sd = np.std(diff, axis=0)
        axes.scatter(mean, diff, color=c, label=name, **kwargs)
        # mean line
        axes.axhline(md, color=c, linestyle='-', label="Mean difference")
        # higher STD bound
        axes.axhline(md + 1.96*sd, color=c, linestyle='--', label="Limits of agreement of difference")
        # lower STD bound
        axes.axhline(md - 1.96*sd, color=c, linestyle='--')

    plt.legend()

    return fig, axes

def get_dir_name_type(out_name, out_type='png', out_dir=None): # todo: can form be improved?
    """
    Standardized behaviour for filenames.

    Parameters
    ----------
    out_name : str
        output filename.
        if it contains an extension (e.g. 'MyName.png'), the extension is added to out_ext.
    out_type : str or iterable, optional (default: None)
        contains file extensions to be plotted.
        if None, '.png' is used. If '.' is missing, it is added.
    out_dir : str, optional (default: None)
        path to the output directory.
        if None, uses the current working directory.

    Returns
    -------
    out_dir : str
    out_name : str
    out_ext : set
        file extensions
    """
    # directory
    if not out_dir:
        out_dir = ''
    out_dir = os.path.abspath(out_dir)
    # file name
    (out_name, ext) = os.path.splitext(out_name)  # remove extension
    # file type
    if not out_type:
        if ext:
            out_type = ext
        else:
            out_type = '.png'
    # convert to a set
    if isinstance(out_type, str):
        out_type = {out_type}
    else:  # some iterable
        out_type = set(out_type)
    if ext:
        out_type.add(ext)
    out_type = {ext if ext[0] == "." else "." + ext for ext in out_type}  # make sure all entries start with a '.'

    return out_dir, out_name, out_type

class QA4SMPlotter():
    """
    Class to create image files of plots from the validation results in a QA4SMImage
    """
    def __init__(self, image, out_dir=None):
        """
        Create box plots from results in a qa4sm output file.

        Parameters
        ----------
        image : QA4SMImg
            The results object.
        out_dir : str, optional (default: None)
            Path to output generated plot.
            If None, defaults to the current working directory.
            The default is None.
        """
        self.img = image
        self.out_dir = out_dir

        self.ref = image.ref_dataset #todo: check working

    @staticmethod
    def _box_stats(ds:pd.Series, med:bool=True, iqr:bool=True, count:bool=True) -> str:
        """
        Create the metric part with stats of the box (axis) caption

        Parameters
        ----------
        ds: pd.Series
            data on which stats are found
        med: bool
        iqr: bool
        count: bool
            statistics

        Returns
        -------
        stats: str
            caption with summary stats
        """
        # interquartile range
        iqr = ds.quantile(q=[0.75,0.25]).diff()
        iqr = abs(float(iqr.loc[0.25]))

        met_str = []
        if med:
            met_str.append('median: {:.3g}'.format(ds.median()))
        if iqr:
            met_str.append('Interq. range: {:.3g}'.format(iqr))
        if count:
            met_str.append('N: {:d}'.format(ds.count()))
        stats = '\n'.join(met_str)

        return stats

    @staticmethod
    def _box_caption(dss_meta, tc:bool=False) -> str:
        """
        Create the dataset part of the box (axis) caption

        Parameters
        ----------
        dss_meta: id, dict
            id and dictionary from MetricVariable.get_varmeta(), for the metric dataset (non-tc) or for the other
            satellite dataset (tc)
        tc: bool, default is False
            True if TC. Then, caption starts with "Other Data:"

        Returns
        -------
        capt: str
            box caption
        """
        ds_parts = []
        id, meta = dss_meta
        ds_parts.append('{}-{}\n({})'.format(
            id, meta['pretty_name'], meta['pretty_version']))
        capt = '\n and \n'.join(ds_parts)

        if tc:
            capt = 'Other Data:' + '\n' + ds_part

        return capt

    @staticmethod
    def _get_parts_name(var, type='bplot_basic'):
        """
        Create parts for title according to the type of plot

        Parameters
        ----------
        var: MetricVar
            variable for a metric
        type: str
            type of plot

        Returns
        -------
        parts: list
            list of parts for title
        """
        parts = []
        ref, mds, other = [meta for meta in var.get_varmeta()]
        if type == 'bplot_basic':
            parts.append(ref[0])
            parts.extend([ref[1]['pretty_name'], ref[1]['pretty_version']])

        elif type in ['bplot_tc', 'mapplot_basic', 'mapplot_tc']:
            parts.append(mds[0])
            parts.extend([mds[1]['pretty_name'], mds[1]['pretty_version']])
            parts.append(ref[0])
            parts.extend([ref[1]['pretty_name'], ref[1]['pretty_version']])

            if type == 'mapplot_tc':
                parts.append(other[0])
                parts.extend([other[1]['pretty_name'], other[1]['pretty_version']])

        return parts

    @staticmethod
    def _titles_lut(type):
        """
        Lookup table for plot titles

        Parameters
        ----------
        type: str
            type of plot
        """
        titles = {'bplot_basic': 'Intercomparison of \n{} \nwith {}-{} ({}) \nas the reference',
                  'bplot_tc': 'Intercomparison of {} \nfor {}-{} ({}) \nwith {}-{} ({}) \nas the reference',
                  'mapplot_basic': '{} for {}-{} ({}) with {}-{} ({}) as the reference',
                  'mapplot_tc': '{} for {}-{} ({}) with {}-{} ({}) and {}-{} ({}) as the reference'}

        try:
            return titles[type]

        except IndexError as e: # todo: test
            e.message = "type '{}' is not in the lookup table".format(type)

            raise e

    def create_title(self, var, metric:str, type:str) -> str:
        """
        Create title of the plot

        Parameters
        ----------
        var: MetricVar
            variable for a metric
        type: str
            type of plot
        """
        parts = [globals._metric_name[metric]]
        parts.extend(self._get_parts_name(var=var, type=type))
        title = self._titles_lut(type=type).format(*parts)

        return title

    @staticmethod
    def _filenames_lut(type):
        """
        Lookup table for file names

        Parameters
        ----------
        type: str
            type of plot
        """
        names = {'bplot_basic': 'boxplot_{}',
                 'bplot_tc': 'boxplot_{}_for_{}-{}',
                 'mapplot_common': 'overview_{}',
                 'mapplot_double': 'overview_{}_{}-{}_and_{}-{}',
                 'mapplot_tc': 'overview_{}_for_{}-{}_with_{}-{}_and_{}-{}'}

        try:
            return names[type]

        except IndexError as e: # todo: test
            e.message = "type '{}' is not in the lookup table".format(type)

            raise e

    def create_filename(self, var, metric:str, type:str) -> str:
        """
        Create name of the file

        Parameters
        ----------
        var: MetricVar
            variable for a metric
        type: str
            type of plot
        """
        name = self._filenames_lut(type=type)
        ref_meta, mds_meta, other_meta = var.get_varmeta()
        parts = [metric, mds_meta[0], mds_meta[1], ref_meta[0], ref_meta[1]]

        if type == 'mapplot_tc':
            parts.extend([other_meta[0], other_meta[1]])

        return name.format(*parts)

    def _yield_values(self, metric: str, add_stats:bool=globals.boxplot_printnumbers) -> pd.DataFrame:
        """
        Get iterable with pandas dataframes for all variables of a metric to plot

        Parameters
        ----------
        add_stats : bool, optional (default: from globals)
            Add stats of median, iqr and N to the box bottom.

        Yield
        -----
        df: pd.DataFrame
            dataframe with variable values and caption name
        """
        for n, Var in enumerate(self.img._iter_vars(**{'metric':metric})):  # for wach var in the metric
            ref_meta, mds_meta, other_meta = Var.get_varmeta()
            box_cap_ds = self._box_caption(mds_meta)
            df = Var.values
            if Var.g == 0:
                box_cap_ds = 'All datasets'
            else:
                box_cap_ds = self._box_caption(mds_meta)
            if add_stats:
                box_stats = self._box_stats(df[Var.varname])
                box_cap = '{}\n{}'.format(box_cap_ds, box_stats)
            else:
                box_cap = box_cap_ds
            df.columns = [box_cap]

            yield df, Var

    def _boxplot_definition(self, metric:str,
                            df:pd.DataFrame,
                            type:str,
                            var=None,
                            watermark_pos=globals.watermark_pos,
                            offset=0.1,
                            **kwargs):
        """
        Define parameters of plot

        Parameters
        ----------
        df: pd.DataFrame
            dataframe to plot
        type: str
            one of _titles_lut
        watermark_pos: str
            position of watermark
        offset: float
            offset of boxplots
        """
        # plot label
        parts = [globals._metric_name[metric]]
        parts.append(globals._metric_description[metric].format(
            globals._metric_units[self.ref]))
        label = "{}{}".format(*parts)
        # generate plot
        figwidth = globals.boxplot_width # todo: check width
        figsize = [figwidth, globals.boxplot_height]
        fig, ax = boxplot(df=df, label=label, figsize=figsize, dpi=globals.dpi)

        # when we only need reference dataset from variables (i.e. is the same):
        if not var:
            for Var in self.img._iter_vars(**{'metric':metric}):
                var =Var
                break
        title = self.create_title(var, metric, type=type)
        ax.set_title(title, pad=globals.title_pad)
        # add watermark
        if globals.watermark_pos not in [None, False]:
            make_watermark(fig, watermark_pos, offset)

        return fig, ax

    def boxplot_tc(self, metric, out_type=None):
        """
        Creates a boxplot for TC metrics. Saves a figure and returns Matplotlib fig and ax objects for further processing.

        Parameters
        ----------
        metric : str
            metric that is collected from the file for all datasets and combined
            into one plot.
        out_name : [ None | str ], optional
            Name of output file.
            If None, defaults to a name that is generated based on the variables.
        out_type : [ str | list | None ], optional
            The file type, e.g. 'png', 'pdf', 'svg', 'tiff'...
            If list, a plot is saved for each type. The default is png
        kwargs: arguments for _boxplot_definition function
        """
        fnames = list()  # list of filenames
        for df, Var in self._yield_values(metric=metric):
            # create plot
            fig, ax = self._boxplot_definition(metric=metric,
                                               df=df,
                                               type='bplot_tc',
                                               var=Var,
                                               **kwargs)
            mds_meta = Var.get_varmeta()[1]
            # save
            out_name = self.create_filename(Var, metric, type='boxplot_tc')
            out_dir, out_name, out_type = get_dir_name_type(out_name, out_type, self.out_dir) # todo: check save process
            if not os.path.exists(out_dir):
                os.makedirs(out_dir)

            for ending in out_type:
                fname = os.path.join(out_dir, out_name+ending)
                if os.path.isfile(fname):
                    warnings.warn('Overwriting file {}'.format(fname))
                plt.savefig(fname, dpi='figure', bbox_inches='tight')
                fnames.append(fname)
            plt.close()

        return fnames

    def boxplot_basic(self, metric, out_name=None, out_type=None, **kwargs): # todo: check outnmae/out_type
        """
        Creates a boxplot_basic for basic metrics. Saves a figure and returns Matplotlib fig and ax objects for further
        processing.

        Parameters
        ----------
        metric : str
            metric that is collected from the file for all datasets and combined
            into one plot.
        out_name : [ None | str ], optional
            Name of output file.
            If None, defaults to a name that is generated based on the variables.
        out_type : [ str | list | None ], optional
            The file type, e.g. 'png', 'pdf', 'svg', 'tiff'...
            If list, a plot is saved for each type. If None, no file is saved.
        kwargs: arguments for _boxplot_definition function

        Returns
        -------
        fig : matplotlib.figure.Figure
            Figure containing the axes for further processing.
        ax : matplotlib.axes.Axes or list of Axes objects
            Axes or list of axes containing the plot.
        """
        fnames = []  # list to store all filenames
        values = []
        for df, Var in self._yield_values(metric=metric):
            values.append(df)
        values = pd.concat(values)
        # create plot
        fig, ax = self._boxplot_definition(metric=metric,
                                           df=values,
                                           type='bplot_basic',
                                           **kwargs)
        # save or return plotting objects
        if not out_name:
            out_name = 'boxplot_{}'.format(metric)

        if self.out_dir is None:
            return fig, ax

        else:
            out_name = self.create_filename(Var, metric, type='boxplot_basic')
            out_dir, out_name, out_type = get_dir_name_type(out_name, out_type, self.out_dir)
            if not os.path.exists(out_dir):
                os.makedirs(out_dir)
            for ending in out_type:
                fname = os.path.join(out_dir, out_name+ending)
                plt.savefig(fname, dpi='figure', bbox_inches='tight')
                fnames.append(fname)
            plt.close('all')

            return fnames

    def mapplot_var(self, var, out_name=None, out_type=None, **plot_kwargs):
        """
        Plots values to a map, using the values as color. Plots a scatterplot for
        ISMN and a image plot for other input values.

        Parameters
        ----------
        var : QA4SMMetricVariab;e
            Var in the image to make the map for.
        out_name : [ None | str ], optional
            Name of output file.
            If None, defaults to a name that is generated based on the variables.
        out_type : [ str | list | None ], optional
            The file type, e.g. 'png', 'pdf', 'svg', 'tiff'...
            If list, a plot is saved for each type. If None, no file is saved.
        **plot_kwargs : dict, optional
            Additional keyword arguments that are passed to dfplot.

        Returns
        -------
        fig : matplotlib.figure.Figure
            Figure containing the axes for further processing.
        ax : matplotlib.axes.Axes or list of Axes objects
            Axes or list of axes containing the plot.
        """
        ref_meta, mds_meta, other_meta = var.get_varmeta()
        metric = var.metric
        ref_grid_stepsize = self.img.ref_dataset_grid_stepsize

        # create mapplot
        fig, ax = mapplot(df=var.values[var.varname],
                          metric=metric,
                          ref_short=ref_meta[1]['short_name'],
                          ref_grid_stepsize=ref_grid_stepsize,
                          plot_extent=self.img.extent,
                          **plot_kwargs)
        # title and plot settings
        if var.g == 0:
            title = "{} between all datasets".format(globals._metric_name[metric])
            out_name = self.create_filename(var, metric, type='mapplot_common')
        elif var.g == 2:
            title = self.create_title(var=var, metric=metric, type='mapplot_basic')
            out_name = self.create_filename(var, metric, type='mapplot_double')
        else:
            title = self.create_title(var=var, metric=metric, type='mapplot_tc') # todo: check titles are ok with QA4SM
            out_name = self.create_filename(var, metric, type='mapplot_tc')

        ax.set_title(title, pad=globals.title_pad)
        if globals.watermark_pos not in [None, False]:
            make_watermark(fig, globals.watermark_pos, for_map=True)

        if self.out_dir is None:
            return fig, ax

        else:
            fnames = []
            out_dir, out_name, out_type = \
                get_dir_name_type(out_name, out_type, self.out_dir)
            if not os.path.exists(out_dir):
                os.makedirs(out_dir)
            for ending in out_type:
                fname = os.path.join(out_dir, out_name+ending)
                plt.savefig(fname, dpi='figure', bbox_inches='tight')
                fnames.append(fname)
            plt.close('all')

            return fnames

    def mapplot(self, metric, out_type=None, **plot_kwargs):
        """
        Plot ALL variables for a given metric in the loaded file.

        Parameters
        ----------
        filepath : str
            Path to the *.nc file to be processed.
        metric : str
            Name of a metric. File is searched for variables for that metric.
        **kwargs : dict, optional
            Additional keyword arguments that are passed to mapplot_var

        Returns
        -------
        fnames : list
            List of files that were created
        """
        fnames = []
        for Var in self.img._iter_vars(**{'metric':metric}):
            fns = self.mapplot_var(Var,
                                   out_name=None,
                                   out_type=out_type,
                                   **plot_kwargs)
            plt.close('all')
            for fn in fns: fnames.append(fn)

        return fnames
